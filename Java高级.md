

# 一、API和Scanner类

Scanner类的功能，可以实现键盘输入数据，到程序当中
* 引用类型的使用步骤：
*   1、导包
*       import 包路径.类名称
*   2、创建
*       类名称 对象名 = new 类名称();
*   3、使用
*       对象名.成员方法名()
*   获取键盘输入的一个int数字，int num = sc.nextInt();
*   获取键盘的输入的一个字符串，String str = sc.next();

# 二、匿名对象

定义：就是只有右边的对象，没有左边的名字和赋值运算符

# 三、Random的概述与基本使用

## Random类用来生成随机数字。

## 三个步骤：

* 1、导包
* import java.util.Random;
* 2、创建
* Random r = new Random(）;
*  3、使用
*  获取一个随机的int数字，（范围是int所有范围，有正负两种，），int num = r.nextInt();
*  获取一个随机的int数字，（参数代表了范围，左闭右开区间），int num = r.nextInt(3);
*  实际上代表的含义是[0,3),也就是0-2


# 四、数组对象

###    ArrayList的概述

 	数组的长度不可以发生改变
    但是ArrayList的长度是可以随意改变的

​    对于ArrayList来说,有一个尖括号<E>,代表泛型
​    泛型,也就是装在集合当中的所有元素,全是统一的什么类型
​    注意,泛型只能是引用类型,不能是基本类型
​    
​    注意事项:
​    对于ArrayList集合来说,直接打印得到的不是地址值,而是内容.
​    如果内容是空,得到的是一个空的字符串.[]
​    
​    

### ArrayList当中的常用方法有:

​    public boolean add(E e),向集合添加元素,参数类型与泛型一致,返回值代表添加是否成功
​        备注;对于ArrayList集合来说,add添加动作一定是成功的,所以返回值可以可不用,
​        但是对于其他集合来说,add添加动作不一定能够成功,
​    public E get(int index),从集合当中获取元素,参数是索引值,从0开始,返回值是对应位置的元素
​    public E remove(int index),从集合当中删除元素,参数是索引值,从0开始,返回值是被删除掉的元素
​    public int size():获取集合的尺寸长度,返回值是集合中包含的元素个数

​    如果希望向集合ArrayList当中存储基本数据类型，就必须使用基本数据类型对应的“包装类”

​    基本类型        包装类
​    byte            Btye
​    short           Short
​    int             Integer
​    long            Long【特殊】
​    float           Float
​    double          Double
​    char            Character【特殊】
​    boolean         Boolean

# 五、字符串

### 一、

​	java.lang.String代表字符串
​    API当中说，java程序当中所有的字符串字面值（如"abd"）都作为此类的实例实现
​    其实就是说，程序当中所有的双引号字符串，都是String类的对象，（就算没有new，也照样也是）

​    字符串的特点：
​        1、字符串的内容不可改
​        2、正因为字符串不可改变，所以字符串是可以共享使用的
​        3、字符串效果相当于是char[]字符数组，但是底层原理是byte[]字节数据

###  二、

​    ==是进行对象的地址值的比较，如果确实要内容的比较，可以使用两个方法
​        public boolean equals(Object ocj),参数可以是任何对象，只有参数是一个字符串并且内容相同才会给true，否		则返回false。
​        注意事项：
​            1、任何对象都能用object对象进行接收
​            2、equals方法具有对称性。a.equals(b)和b.equals(a)效果一样
​            3、如果比较双方，一个常量，一个变量，推荐把常量字符串放在前面

​        public boolean equalsIgnoreCase(String str),忽略大小写，进行内容比较,只能用于字母

###  三、String当中与获取相关的方法有：

​        public String concat(String str)：将当前字符串和参数字符串拼接成为新的字符串
​        public int length():获取字符串当中含有的字符个数,拿到字符串长度
​        public char charAt(int index):获取指定索引位置的单个字符(索引从0开始)
​        public int indexOf(String str):查找字符串在本字符串当中首次出现的索引位置,如果没有就返回-

### 四、String当中与转换相关的常用方法:

​    public char[] toCharArray(),将当前字符串拆分成字符数组作为返回值
​    public byte[] getBytes() ,获得当前字符串底层的字符数组作为返回值
​    public String replace(CharSequence oldString,CharSequence newString)
​    将所有的老字符串替换成为新的字符串,返回替换过的新的字符串

​    分割字符串的方法;
​           public String[] split(String regex),按照参数的规则,将字符串切分呢为若干个字符串

​    注意事项:
​            split方法的参数其实是一个正则表达式,今后学习
​            如果要英文句点,"进行切分".必须写"\\.",(两个反斜杠)

# 六、static关键字

一旦用了static关键字，那麽这样的内容不在属于对象自己，而是属于类；所以凡是本类的对象，都共享一份数据
二、

​        如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享一份数据

三、
        一旦使用的static修饰成员方法，那么这就称为了静态方法
        静态方法不属于对象，而是属于类

​        如果没有static关键字，那么必须首先创建对象，然后通过对象来使用他。
​        如果有了static关键字，那么不需要创建对象，直接就能使用类名来使用它
​        注意事项:
​        1、静态不能直接访问非静态
​        原因：在内存当中是先有的静态内容，后有的非静态的内容
​        2、静态方法中不能用this
​        原因：this代表当前对象，通过谁调用的方法，谁就是当前的对象

​        特点：
​            当第一次用到本类时，静态代码块执行唯一的一次
​        注意：
​            静态内容总是优先于非静态，所以静态代码块比构造方法先执行

五、

​        java.util.Math类是数学相关的工具类，里面提供大量的静态方法，完成与数学运算相关的操作。

​        public static double abs(double num) ：获取绝对值。多种重载
​        public static double ceil(double num):向上取整
​        public static double floor(double num):向下取整
​        public static long round(double num):四舍五入
​     

# 六、继承的概述

一、
    面向对象三大特征：
        封装、继承、多态
        继承是多态的前提，如果没有继承，就没有多态
        继承主要解决的问题是:共性抽取

​    父类：也可以叫做基类或者超类
​    子类:也可以叫做派生类
​    继承关系当中的特点：
​        1、子类可以拥有父类的内容
​        2、子类还可以拥有自己的内容
​      

二、

​    在父子类的继承关系中。如果成员变量重名，则创建子类对象时，有两种访问方法：
​    直接通过子类对象访问成员变量：
​        等号左边是谁，就优先用谁，没有则向上找
​    间接通过成员方法访问成员变量:
​        该方法属于谁，就优先用谁，没有则向上找
 	
三、 	
​            区分子类方法中重名的三种：
​            局部变量                直接写变量名
​            本类中的成员变量        this.成员变量名
​            父类的成员变量           super.成员变量名
 四、
​	
​    继承中，成员方法的访问特点：
​        在父子类的继承关系当中，创建子类对象，访问成员变量的方法的规则，
​            创建的对象是谁，就有优先用谁，如果没有就向上找
​    注意事项：
​           无论是成员方法还是成员变量，   如果没有都是向上找父类，绝不会向下找子类
​	 
​	 
​	 =============================================================
​	 重写：（Override）
​	 概念：在继承关系当中，方法的名称一样，参数列表也一样
​	 
​	重写：（Override）：方法名称一样，参数列表【也一样】，也可以叫做覆盖，覆写
​	重载：（Overload）：方法名称一样，参数列表【不一样】
​	 
​	 
五、
​            覆盖重写中的注意事项：
​            1、必须保证父子类之间方法名称相同，参数列表也相同。
​            @Override：写在方法前面，用来检测是不是有效的方法覆盖重写
​            注解：可以写可不写
​            2、子类方法的返回值必须【小于等于】父类方法的返回值
​            3、子类方法的权限必须【大于等于】父类方法的权限修饰符

​            小扩展提示：public > protected > (default) > private
​            备注：default不是关键字default，而是留空。什么都不写 
​    

   六、
 	
    继承关系中，父子类构造方法的访问特点：
        1、子类方法中有一个默认隐含的”super“调用，所以一定是先调用的父类构造，后执行的子类构造。
        2、可以通过super关键字来子类构造来调用父类重载构造
        3、super的父类构造调用，必须是子类构造方法的第一个语句，不能是子类构造调用多次super
        总结：子类必须调用父类构造方法，不写则赠送super，还必须是第一个
        	只有子类构造方法，才能调用父类构造方法（用到super关键字）

 七、super关键字的用法有三种:
        1、在子类的成员方法中，访问父类的成员的变量
        2、在子类的成员方法中，访问父类的成员方法
        3、在子类的构造方法中，访问父类的构造方法

 	

 八、Java继承的三个特点：

 		Java语言是单继承的，一个类的直接父类只能有一个
 		Java语言可以多级继承
 		一个子类的直接父类是唯一的，但是一个父亲可以拥有很多个子类
	

# 七、抽象

​    抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束
​    抽象类：抽象方法所在的类，必须是抽象类。在class之前加上abstract即可

​    如何使用抽象类和抽象方法:
​    1、不能直接创建new抽象类对象
​    2、必须使用一个子类来继承抽象父类
​    3、子类必须覆盖重写父类当中所有的抽象方法
​    覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号
​    4、创建子类对象进行使用

# 八、接口

接口就是一种公共的标准规范

只要符合规范标准，就可以大家通用

### 一、接口定义的基本格式：

接口就是多个类的公共规范接口就是引用数据类型，最重要的内容就是其中的，抽象方法

如何定义一个接口的格式： public interface 接口名称{    

 //接口内容

 } 

注意：换成关键字interface之后，编译生成的字节码文件仍然是：.java-->.class java7-->包含:             1、常量             2、抽象方法  

java8-->包含:             1、默认方法             2、静态方法  

java9-->包含：             1、私有方法

### 二、接口的抽象方法的使用

在任何版本的Java中，接口都能定义抽象方法

格式：

​    public abstract 返回值类型 方法名称(参数列表);

注意事项：         1、接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract         2、两个关键字修饰符，可以选择性的省略         3、方法的三要素可以随意定义

### 三、接口的使用步骤

   1、接口不能直接使用，必须有一个”实现类“来实现该接口      

​	格式：public class 实现类的名称 impelments 接口名称{

​               //。。           

}   

​	2、接口的实现类必须覆盖重写（实现）接口中所有的抽象方法  

 	实现：去掉abstract关键字，加上方法体大括号。   

​	3、创建实现类的对象，进行使用   注意：       如果实现类并没有覆盖重写接口中所有的抽象方法，那麽这个实现类自己为抽象类

### 四、接口默认方法：

​	从Java8开始，接口里允许使用定义默认方法

​	格式：public default 返回值类型 方法名称(参数列表){方法体}

​	备注：接口当中的默认方法，可以解决接口升级的问题

### 五、接口的私有方法的使用：

​	从Java9开始，接口当中允许定义私有方法

​	1、普通私有方法：解决多个默认方法之间重复代码的问题

​	格式：private 返回值类型 方法名称（参数列表）{方法体}

​	2、静态私有方法：解决多个静态方法之间重复代码的问题

​	格式：private static 返回值类型 方法名称（参数列表）{方法体}

### 六、接口的常量

​	接口当中也可以定义“成员变量”，但必须是使用public static final三个关键字进行修饰；从效果上看，这其实就是接口的【常量】。

格式：public static final 数据类型 常量名称 = 数据值；

注意：一旦使用final关键字进行修饰，说明不可改变

接口当中的常量，可以省略public static final，注意，不写也照样是这样

### 七、接口的内容小结

​	在Java9+，版本中，接口的内容可以有：

​	1、成员变量其实是常量，格式：

​	public static final 数据类型 常量成员 = 数据值

​	注意：常量必须进行赋值，而且一旦赋值不能改变

​				常量名称完全大写，用下划线分隔

​	2、接口中最重要的就是抽象方法，格式：

​	public abstract 返回值类型 方法名称（参数列表）；

​	注意：实现类必须覆盖重写接口中所有的抽象方法，除非实现类是抽象类

​	3、从Java8开始，接口里允许定义默认方法，格式：

​	public default 返回值类型 方法名称 （参数列表）{方法体}

​	注意：默认方法也可以被覆盖重写

​	4、从Java8开始，接口里允许定义静态方法，格式：

​	public static 返回值类型 方法名称（参数列表）{方法体}

​	注意：应该通过接口名称进行调用，不能通过实现类对象进行调用接口静态方法

​	5、从Java9开始，接口里允许定义私有方法，格式：

​	普通私有：private 返回值类型 方法名称（参数列表） {方法体}

​	静态私有：private static 返回值类型 方法名称（参数列表）{方法体}

​	注意：private的方法， 只有接口自己才能使用，不能被实现类或别人使用

### 八、接口之间的多继承

​	1、类与类之间是单继承的，直接父类只有一个。

​	2、类与接口之间是多实现的。一个类可以实现多个接口

​	3、接口与接口之间是是多实现的

​	注意事项：

​					多个父接口的抽象方法重复，没关系

​					多个父接口的默认方法重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】

# 八、多态

### 一、多态的概述

面向对象三大特征：封装、继承、多态

extends继承或者implement实现，是多态的前提

### 二、多态的格式及使用

代码当中体现多态性，其实就是一句话：父类引用指向子类对象

格式：父类名称 对象名 = new 子类名称();

或者：接口名称 对象名 = new 实现类名称();

### 三、多态中成员变量的使用特点

注意：成员变量不能进行覆盖重写

访问成员变量的两种方式：

​	1、直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找

​	2、间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找

### 四、多态中，成员方法的使用特点

1、在多态的代码中，成员方法的访问规则：

​	看new的是谁，就优先用谁，没有则向上找

2、口诀：

​	成员变量：编译看左边，运行看左边

​	成员方法：编译看左边，运行看右边

### 五、使用多态的好处

​	无论右边new的时候换成那个子类对象，等号左边的调用方法都不会改变

### 六、对象的转型

​	向上转型：其实就是多态的写法：

​	格式：父类名称 对象名 = new 子类名称();

​	含义：右侧创建一个子类对象，把它当作父类来看待

​				父类引用指向子类对象

​	向下转型：其实是一个【还原】的动作

​	格式：子类名称 对象名 = (子类名称) 父类对象;

​	含义：将父类对象【还原】成为本来的子类对象	

​	注意事项：

​		向下转型时：new的时候是什么对象，转换回来也是什么，不会发生改变；若错误引用，会发生异常，java.lang.ClassCastException:类转换异常

### 七、用instanceof关键字进行

​	如何才能知道父类引用的对象，本来是什么子类呢？

​	格式：

​			对象名 instanceof 类名称

​			这将会得到一个boolean值结果，也就是判断前面的对象能不能当作后面类型的实例

​		注意：向下转型一定进行instanceof判断



# 九、final关键字

### 一、final关键字的概述

final关键字代表最终、不可改变的

常见四种用法：

1、可以用来修饰一个类

​	当final关键字用来修饰一个类的时候，格式：

​	public final class 类名称{

​		

​	}

​	含义：当前这个类，不能有任何子类

​	注意：一个类如果是final的，那么其中的所有成员方法都不可以进行覆盖重写

2、可以用来修饰一个方法

​	当final关键字用来修饰一个方法的时候，这个方法是最终方法，也就是不能被覆盖重写

​	格式：

​		修饰符 final 返回值类型 方法名称 (参数列表){

​			方法体;

​		}

​	注意事项：对于类、方法来说，abstract（抽象）关键字和final关键字，不能同时使用，因为矛盾；

3、还可以用来修饰一个局部变量

​	一旦使用final用来修饰局部变量，那麽这个变量就不能进行更改

​	对于基本类型来说，不可变说的是变量当中的数据不可改变

​	对于引用类型来说，不可变说的是变量当中的地址值不可改变

4、还可以用来修饰一个成员变量

​	对于成员变量来说，如果使用final关键字修饰，那么这个变量照样也是不可变

​	1、由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值

​	2、对于final成员变量，要么使用直接赋值，要么通过构造方法赋值

​	3、对于构造方法赋值，必须保证类当中所有的重载的构造方法，都最终会对final的成员变量进行赋值

### 二、权限修饰符

​	Java中有四种权限修饰符：

​								public > protected > (default) > private（私有）

注意：（default）并不是关键字“default”，而是根本不写

同一个类						都可以访问																

同一个包						private并不能访问，其余都可以																								

不同包子类					default和private不能访问														 	

不同包非子类                   除了public都不可以访问                                                    																										

### 三、内部类

一、内部类的概述：

​	一个类的内部包含另一个类：内部类

​	分类：

#### 		1、成员内部类

​				定义格式：

​					修饰符 class 外部类名称{

​								修饰符 class 内部类名称{

​									//。。。。

​								}								

​					}

​	注意：内用外，随意调用；外用内，需要内部类对象 

​	如何使用成员内部类？有两种方法:

​				①间接方式：在外部类的方法当中使用内部类：然后main只是调用外部类的方法

​				②直接方式：公式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称()

​	内部类的同名变量访问:如果出现了重名现象。

那麽格式是：外部类名称.this.外部类成员变量名

#### 		2、局部内部类（包含匿名内部类）

​			一个类定义在方法内部的，那麽这个类就是局部内部类

​			局部：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

​			定义格式:

```
	修饰符 class 外部类名称{

​		修饰符 返回值类型 外部类方法名称（参数列表）{
			class 局部类名称{
				//。。
			}
​		}

​	}
```

​		小结一下类的权限修饰符：

​		public > protected > (default) > private

​		定义一个类的时候，权限修饰符的定义:

​		1、外部类 ：public / （default）

​		2、成员内部类：public / protected / (default) / private

​		3、局部内部类：什么都不能写

局部内部类,如果希望访问所在方法的局部变量，那麽这个局部变量必须是【有效的final的】

原因：

​			1、new出来的对象在堆内存当中

​			2、局部变量是跟着方法走的，在栈内存当中

​			3、方法运行之后，立刻出栈，局部变量就会立刻消失

​			4、但是new出来的对象会在栈内存当中持续存在，知道垃圾回收为止

#### 3、匿名内部类：

​	如果接口的实现类（或者该父类的子类）只需要使用一次，

​	那麽这种情况下，就可以省略掉该类的定义，而改为使用【匿名内部类】

​	匿名内部类的定义格式：

​		接口名称 对象名 = new 接口名称() {

​				//覆盖重写所有抽象方法

​		};

​		注意：1、匿名内部类。【在创建对象的时候】，只能使用唯一的一次；如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义实现类了。

​					2、匿名对象。在【调用方法】的时候，只能调用唯一一次；如果希望同一个对象，调用多次方法，那么必须给对象起一个名字

​					3、匿名内部类是省略了【实现类/子类】，但是匿名对象是省略了【对象名称】



类作为成员变量类型：



# 十、Object类

### 一、equals方法

equals方法源码：

```
 public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
   
 参数：Object可以传递任意的对象
 		==比较运算符：返回值是一个布尔值
 			基本数据类型：比较的是值
 			引用数据类型：比较的是地址值
```

Object类的equals方法，默认比较的是两个对象的地址值，没有意义。

所以我们要重写equals方法，比较对象的属性（name，age）

### 二、Date类

java.util.Date：表示日期和时间的类

类 Date 表示特定的瞬间，精确到毫秒

毫秒：千分之一秒， 1000毫秒=1秒

原点：1970年1月1日  00:00:00（此处时间是英国格林威治）

中国属于东八区，会把时间增加八个小时

时间原点：1970年1月1日  08:00:00

#### Date类的构造方法：

1、无参构造方法：

获取当前系统的日期和时间

2、有参构造方法：

（Long date）：传递毫秒值，把毫秒值转换成Date日期

getTime：把日期转换成毫秒值，自1970年1月1日开始

#### DateFormat类

功能:格式化（日期-->文本）、解析（文本-->日期）

抽象类，无法直接创建对象使用，可以使用DateFormat类的子类

​	SimpleDtaeFormat

format：把Date日期，格式化为符合模式的字符串

parse：把文本解析问日期

 如果字符串和构造方法模式不一样，那么程序就会抛出异常，解析异常（ParseException）

### 三、Calendal类（日历类）

1、概述

抽象类，里面提供了很多操作日历字段的方法

无法直接创建对象使用，里面有一个静态方法getInstance(),该方法返回了Calendar的子类对象

2、成员方法

public int get(int field):返回指定字段的值

参数：传递指定的日历字段，（YERA、MONTH）

返回值:日历字段代表具体的值

public void set(int field,int value):将给定的日历字段设置为给定值

public abstract void add(int field,int amount):根据日历的规则，为给定的日历字段，添加或者减去指定的时间量

参数：int field ：传递指定的日历字段（YEAR，MONTH）

​			int amount：增加/减少指定的量

public Date getTime():返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象

### 四、System类 （系统类）

public static long currentTimeMillis():返回以毫秒为单位的当前时间

用来测试程序的效率

public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)：将数组中的指定的数据拷贝到另一个数组当中，

参数：

​	src：原数组

​	srcPos：原数组中的起始位置

​	dest：新数组

​	destPos：新数组当中的起始位置

​	length：复制数组元素的数量

### 五、StringBuilder类

字符串缓冲区，可以提高字符串的操作效率，（看成一个长度可以变换的字符串）

底层是一个数组，但是没有被final修饰，可以改变长度

byte[] value = new byte[16];

StringBuilder的初始容量为16；

StringBuilder在内存中始终是一个数组，占用空间，少效率高；如果超出了StringBuilder的容量，会自动扩容

构造方法：

StringBuilder():构造一个不带任何字符的字符串生成器，其初始容量为

16个字符

StringBuilder(String str):构造一个字符串生成器，其初始化为指定的字符串内容

链式编程：方法的返回值是一个对象，可以继续调用方法



String和StringBuilder可以相互转换：

​	String->StringBuilder可以使用StringBuilderd的构造方法

​	StringBuilder(String str):构造一个字符串生成器，其初始化为指定的字符串内容

StringBuilder->String：可以使用StringBuilder中的toString方法

​	public String toString()：将当前的StringBuilder对象转换成String对象

### 六、包装类

#### 一、概念

就是使用一个类把对应的数据的数据类型给装起来

#### 二、装箱与拆箱

装箱：把基本数据类型，包装到包装类当中（基本数据类型的数据->	包装类）

​	构造方法：Integer(int value)：构造一个新分配的Integer对象，他表示指定的int值

​						Integer(String s):构造一个新分配的Integer对象，他表示String参数所指示的int值（注意：传递的字符串必须是int类型，否则就会抛出异常）

​	静态方法：static Integer valueOf(int i)返回一个指定的int值的Integer实例

​						static Integer valueOf(String s)返回保存指定的值的Integer对象				

拆箱：在包装类当中，取出基本数据类型的数据（包装类->基本数据类型）

### 七、集合框架

#### 一、概述

​	Vector集合

​	ArrayList集合

​	LinkedList集合

​	TreeSet集合

​	HashSet集合

​	LinkedHashSet集合

​	学习集合的目标：1、会使用集合存储数据2、会遍历集合，把数据取出来使用3、掌握每一种集合的特性

​	学习集合框架的方式：（1、学习顶层：学习顶层接口/抽象类中共性的方法所有子类都可以使用，2、使用底层：底层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用）

Collection接口：（1、定义的是所有单列集合当中所有共性的方法2、所有单列集合都可以使用共性的方法3、没有带索引的方法）

分类：List接口（1、有序的集合（存储和取出元素的顺序相同）2、允许存储重复的元素3、有索引，可以使用普通for循环遍历)

​			分类：Vector集合

​						ArrayList集合

​						LinkedList集合

​			Set接口（1、不允许存储重复的元素 2、没有索引 （不能使用普通的for循环遍历））

​				分类：TreeSet集合

​							HashSet集合（前两个为无序的集合，存储和取出的元素顺序可能不一致）

​							LinkedHashSet集合（有序的集合）

​	

继承：子类共性抽取，形成父类（接口）

#### 二、Collection集合常用功能

java.util.Collection接口

​	所有单列集合的最顶层的接口，里边定义了单列集合共性的方法，任意的单列集合都可以使用Collection接口中共性的方法

​	共性的方法：

​	1、public boolean add(E e):把给定的对象添加到当前集合当中返回值是一个布尔值，一般返回都是true，所以可以不用接收

​	2、public boolean remove(E e):把给定的对象在当前集合当中删除返回值是一个布尔值，集合中存在元素，删除元素，返回true；若集合当中，不存在元素，删除失败，返回false

​	3、public boolean contains(E e):判断当前集合中是否包含给定的对象，包含返回true，不包含返回false

​	4、public boolean isEmpty():判断当前集合是否为空若为空，则返回true

​	5、public int size():返回集合当中元素的个数

​	6、public Object[] toArray():把集合中的元素，存储到数组当中

​	7、public void clear():清空集合当中所有的元素，但不删除集合，集合还存在

#### 三、iterator接口

Iterator迭代器：是一个接口，我们无法使用，需要使用Iterator接口的实现类对象，获取实现类的方式比较特殊

Collection接口中有一个方法，	叫iterator(),这个方法返回的就是迭代器的实现类对象

Iterator<E> iterator(),返回在此collection的元素上进行迭代的迭代器



迭代器的使用步骤（重点）：

1、使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）

2、使用Iterator接口中的方法hasNext判断还有没有下一个元素

3、使用Iterator接口中的方法next取出集合中的下一个元素

迭代器的实现原理：

​	迭代器的泛型会跟着集合走

```
Iterator<String> it = coll.iterator();
						获取迭代器的实现类对象，并且会把指针（索引）指向集合的-1索引
```

```
while(it.hasNext()){  //判断有没有下一个元素  
	String i3 = it.next();    做了两件事：1、取出下一个元素2、会把指针向后移动一位
	System.out.println(i3);
}
```

增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写

​		用途：用来遍历集合和数组

​		格式：

```
for(集合/数组的数据类型 变量名:集合/数组名){
	sout();
​}
```

​		注意：新for循环必须有被遍历的目标，目标只能是collection或者数组。新式for仅仅作为遍历操作出现



### 八、泛型

泛型是一种未知的数据类，型当我们不知道使用什么数据类型的时候，就可以使用泛型；泛型也可以看成是一个变量，用来接收数据类型

创建集合对象给的时候就会确定泛型的数据类型。会把数据类型作为参数传递给泛型E

##### 使用泛型的好处：

​	创建集合对象，不使用泛型：

​			好处:集合不使用泛型，默认类型就是Object类型，可以存储任意类型的数据

​			弊端:会引发异常

​	创建集合对象，使用泛型：

​			好处：1、避免了类型转换的问题，存储的是什么类型，取出的就是什么类型	2、把运行期的异常（代码运行之后会抛出的的异常），提升到了编译期（写代码的时候会报错）

​			弊端：泛型是什么类型，就只能存储什么类型的数据



##### 定义含有泛型的方法：

泛型定义在修饰符和返回值类型的中间

格式

```
:修饰符 <泛型> 返回值类型 方法名(参数列表(使用泛型))

​		{    
			//方法体;
​		}
```

含有泛型的方法,在调用方法的时候确定泛型的数据类型传递什么类型的参数,泛型就是什么类型

​					

```
//定义一个含有泛型的静态方法public static <S> void method2(S s){    System.out.println(s);}
//静态方法：不建议创建对象使用；通过类名.方法名(参数)可以直接使用

```

定义含有泛型的接口	